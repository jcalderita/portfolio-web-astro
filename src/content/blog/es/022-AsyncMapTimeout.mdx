---
title: "Async Map Timeout"
slug: "async-map-timeout-es"
date: 2026-01-14
author: "Jorge Calderita"
description: "Actualizaci√≥n de asyncMap para a√±adir control de rate limiting mediante timeouts entre operaciones."
tags: ["Swift", "Vapor"]
cover: "../images/AsyncMapTimeout.png"
publicCover: "AsyncMapTimeout.webp"
coverDescription: "Jorge corriendo en una cinta, pausando brevemente entre cada paso para controlar el ritmo."
publish: true
---
---
## Problema

En el [post sobre AsyncMap](/blog/async-map-es) vimos c√≥mo procesar colecciones de forma **secuencial as√≠ncrona**. Sin embargo, al trabajar con **APIs externas** que implementan rate limiting, nos enfrentamos a un problema cr√≠tico:

```swift
// Procesar 1000 URLs secuencialmente
let results = try await urls.asyncMap { url in
    try await apiClient.fetch(url)  // ‚ö†Ô∏è 1000 llamadas sin pausa
}
// Error 429: Too Many Requests
```

Realizar llamadas consecutivas sin pausas puede:
- **Exceder l√≠mites de rate**: APIs rechazan con <span class="high">429 Too Many Requests</span>.
- **Saturar servicios externos**: sobrecarga de conexiones simult√°neas.
- **Desperdiciar recursos**: forzar reintentos consume m√°s tiempo y ancho de banda.
- **Bloqueos temporales**: algunas APIs bloquean la IP tras m√∫ltiples infracciones.

Necesitamos una forma de **controlar el ritmo** de las operaciones secuenciales, a√±adiendo pausas intencionales entre cada procesamiento.

---

## Soluci√≥n

Actualizamos <span class="high">asyncMap</span> a√±adiendo un par√°metro opcional <span class="high">timeout</span> que introduce una pausa configurable despu√©s de procesar cada elemento.

```swift
extension Sequence {
    func asyncMap<T>(
        timeout: Double? = nil,
        _ transform: (Element) async throws -> T
    ) async throws -> [T] {
        var results = [T]()
        results.reserveCapacity(underestimatedCount)
        for element in self {
            try await results.append(transform(element))
            if let timeout {
                try await Task.sleep(for: .seconds(timeout))
            }
        }
        return results
    }
}
```

**Cambios clave respecto a la versi√≥n original**:

‚ú® Par√°metro <span class="high">timeout: Double? = nil</span> opcional y retrocompatible.<br />
‚è±Ô∏è Si se especifica timeout, a√±ade <span class="high">Task.sleep(for: .seconds(timeout))</span> despu√©s de cada elemento.<br />
üîÑ Mantiene el comportamiento original cuando no se especifica timeout (sin pausas).<br />
üìä Permite ajustar din√°micamente el rate limiting seg√∫n los l√≠mites de cada API.

---

## Resultado

```swift
// Rate limiting: 1 llamada por segundo
let results = try await urls.asyncMap(timeout: 1.0) {
    try await apiClient.fetch($0)
}

// Rate limiting agresivo: 1 llamada cada 5 segundos
let results = try await endpoints.asyncMap(timeout: 5.0) {
    try await scraper.parse($0)
}

// Sin timeout: comportamiento original (m√°xima velocidad)
let results = try await localFiles.asyncMap {
    try await processFile($0)
}
```

Beneficios de esta actualizaci√≥n:

‚è±Ô∏è **Rate limiting configurable**: controla el ritmo de llamadas seg√∫n los l√≠mites de cada API.<br />
üõ°Ô∏è **Prevenci√≥n de bloqueos**: evita errores <span class="high">429</span> y suspensiones temporales de IP.<br />
üîÑ **Retrocompatibilidad total**: sin timeout funciona exactamente igual que antes.<br />
üéØ **Flexibilidad por caso de uso**: ajusta el timeout seg√∫n la tolerancia del servicio externo.<br />
üìä **Procesamiento predecible**: calcula f√°cilmente el tiempo total (n elementos √ó timeout).

Esta actualizaci√≥n convierte <span class="high">asyncMap</span> en una herramienta **completa para procesamiento secuencial controlado**, ideal para integraci√≥n con APIs que imponen l√≠mites de tasa y necesitan un flujo de peticiones regulado.

---
